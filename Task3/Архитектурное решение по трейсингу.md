# Архитектурное решение по трейсингу

## 1 Анализ системы и зоны покрытия трейсингом
Цель: видеть сквозной путь заказа от момента создания до закрытия и быстро определять, где он завис или потерялся

Системы и шаги, подлежащие трейсингу:
- Интернет‑магазин
  - API: INITIATED → FILE_UPLOADED → SUBMITTED (публикация события/заявки)
  - Публикация сообщений в RabbitMQ (если используется)
- MES
  - Получение задания на расчёт (из очереди/из API)
  - Расчёт стоимости (долгие job’ы до 30 мин)
  - MANUFACTURING_STARTED → MANUFACTURING_COMPLETED → PACKAGING → SHIPPED
- CRM
  - PRICE_CALCULATED → MANUFACTURING_APPROVED → CLOSED (получение статусов, создание/обновление заказов)
- Интеграционный слой
  - RabbitMQ: publish/consume, DLQ, retry/backoff, idempotency
  - Внешние партнёры (B2B API): входящие/исходящие запросы, квоты, ошибки
- Базы данных и кэши
  - Ключевые транзакции (вставка/обновление статусов заказа), репликация

Точки, где заказ «ломается» или зависает:
- Публикация события SUBMITTED не дошла до очереди (ошибка publish, неверный exchange/routing)
- Сообщение застряло в очереди (нет консьюмеров/низкая производительность)
- Потеря контекста/идемпотентности (дубли, пропуски статусов)
- Долгий расчёт в MES (узкое место CPU/GPU/алгоритм)
- CRM не получает статусы (ошибки consume, фильтры, падение сервиса)
- Медленные/залипающие транзакции БД (deadlocks, истёкшие таймауты)

Список данных, которые должны попадать в трейсы (минимум):
- trace_id, span_id, parent_span_id
- order_id (корреляционный ключ), external_order_id (у партнёра), partner_id, channel (site|api_b2b)
- status_from, status_to; message_id (RabbitMQ), queue, exchange, routing_key, retry_count
- httpmethod, httptarget, httpstatus_code, netpeerip/port
- dbsystem, dbstatement, dbduration
- job_id (MES), model_id, poly_count_bucket, worker_id/pool
- error_type, error_message, stack (свёрнутый)
- timestamps/duration для p50/p90/p99

## 2 Мотивация
Зачем: сократить MTTR и устранить потери заказов, перейти от «угадывания» к доказательствам по фактам трассировки

Технические/бизнес‑метрики, на которые влияет внедрение трейсинга:
- MTTR инцидентов по заказам (цель: уменьшение на 50%+)
- Доля «потерянных»/зависших заказов (цель: → ~0, обнаружение < 5 мин)
- SLA расчёта стоимости в MES (p95, p99 времени)
- Очередная задержка: publish→consume (RabbitMQ) и статусные лаги SUBMITTED→PRICE_CALCULATED
- Удовлетворённость операторов (ускорение реакции на «новые заказы» и снятие спорных ситуаций)

## 3 Предлагаемое решение
Технологический стек:
- OpenTelemetry SDK/авто‑инструментация:
  - Shop/CRM (Java Spring Boot) - OTel Java Agent, Spring instrumentation
  - MES backend (C#) - OpenTelemetry NET SDK/Auto‑Instrumentation
- OpenTelemetry Collector: приём, обработка, sampling, экспорт
- Хранилище трейсинга: Jaeger
- Grafana: просмотр трейсингов и корреляция с метриками/логами

Обязательная доработка интеграций и сервисов:
- Присваивать и прокидывать trace_id/baggage (order_id, partner_id, channel) во все вызовы и сообщения
- Маскировка чувствительных полей в атрибутах/логах

Визуализация на C4 (новые элементы выделены красным):
- OpenTelemetry Collector (dev/release/prod)
- Tracing backend (Jaeger)
- Инструментация в Shop/CRM/MES сервисах и интеграции с RabbitMQ


## 4 Компромиссы и ограничения
- Нагрузка и стоимость хранения: полные трейсы дороги; применяем смешанная выборка
- Кардинальность атрибутов: ограничить high‑cardinality (например, user_id) - перенос в логи/бизнес‑отчёты
- Проприетарные компоненты/SDK: часть автоинструментации может потребовать ручной обвязки (RabbitMQ headers)
- Долгие джобы: не все среды стабильно держат очень длинные span’ы - предусмотреть heartbeat/интервальные отметки
- Чувствительные данные: ПД не хранить в трейсах; только псевдонимизованные ключи
- Обернуть MES job execution в span с атрибутами model_id/poly_count/priority


## 5 Безопасность
- Аутентификация/SSO к UI трейсинга (OIDC/SAML), только корпоративные аккаунты
- RBAC по ролям: Support, Dev, SRE, Product (разный доступ к атрибутам/логам)
- Шифрование in‑transit (TLS) и at‑rest (KMS)
- Network policies и приватные эндпоинты, ограничение доступа по IP/VPN
- Редакция ПД в агентах/коллекторе, deny‑list атрибутов, сэмплинг конфиденциальных запросов
- Аудит логов доступа и действий в системе трейсинга

## 6 Мониторинг процесса заказа и алертинг (на базе трейсинга)
Триггеры и правила:
- Отсутствие ожидаемого перехода статуса: нет дочернего span в цепочке в течение T (напр, SUBMITTED→PRICE_CALCULATED 30 мин)
- Аномалии длительности: p95/p99 расчёта MES > целевого в течение окна
- Потеря связи: orphan spans (есть PRICE_CALCULATED без SUBMITTED в родителях) → нарушение идемпотентности/корреляции
- Деградация очереди: рост rabbitmq_publish_to_consume_latency и скачки в DLQ
Действия:
- Автоматический инцидент (тикет), уведомление он‑колл
- Политики rate‑limit для партнёров с повышенным error_rate
- Автоскейлинг микросервисов обработки MES при стабильном росте длительностей/очереди
