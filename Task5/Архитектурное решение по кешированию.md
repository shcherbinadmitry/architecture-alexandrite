# Архитектурное решение по кешированию

## 1 Анализ и области кеширования
Проблемы:
- Операторы жалуются на медленный дашборд MES (список заказов по статусам, последние заказы)
- Клиенты недовольны скоростью выполнения заказа (узкое место - длительный расчёт стоимости в MES, очереди)

Что имеет смысл кешировать:
- Серверные ответы для операторского дашборда MES:
  - списки заказов по статусам (MANUFACTURING_STARTED, PACKAGING, SHIPPED и др);
  - агрегаты/счётчики по статусам для шапки дашборда;
  - «новые/последние» заказы (фид)
- Дополнительно (не критично сейчас): справочники (типы изделий, статусы), неизменяемые данные модели

Что не кешируем:
- Результат расчёта стоимости как таковой - он зависит от входной 3D‑модели и параметров; повторное использование ограничено 
- Вместо кеша - очередь воркеров и профилирование, а также кеш для повторяющихся геометрий на уровне MES workers (вне дашборда)

## 2 Мотивация
Зачем кеш:
- Ускорить загрузку дашборда операторов и снизить нагрузку на БД MES
- Стабилизировать UX: отдавать горячие списки за < 200–300 мс при типовых фильтрах
- Снизить частоту чтений к primary БД, использовать read‑реплики эффективнее

Какие проблемы решаем:
- Долгие запросы списков из БД (отсутствие индексов/высокий объём)
- Высокий RPS к API дашборда

Что включаем в кеш:
- Списки: заказы по статусу
- Счетчики: счетчики по статусу заказов(status)
- Ленту: недавние заказы

## 3 Предлагаемое решение
Типы кеширования:
- Серверное кеширование в MES API (C# backend) с использованием Redis (in‑memory, распределённый), паттерн Cache‑Aside для данных чтения
- Точечное клиентское кеширование через HTTP Cache‑Headers (Last‑Modified, Cache‑Control: max‑age=30, stale‑while‑revalidate) 

Почему серверное Cache‑Aside:
- Простой и управляемый: приложение контролирует когда читать/писать в кеш
- Хорошо подходит для списков, где запись идёт не через этот же путь (статус меняет другой поток)
- Проще реализовать поэтапно и безопаснее при частых инвалидациях

Почему не Write‑Through/Write‑Behind:
- Write‑Through увеличит латентность записи статуса и усложнит путь (каждое изменение должно синхронно идти в кеш), при этом записи статусов идут из событийной шины, а читаем из дашборда - потоки разные
- Write‑Behind (асинхронная запись в БД) не подходит по требованиям целостности заказов

Где применим Refresh‑Ahead:
- Для горячих сегментов (status in (MANUFACTURING_STARTED, PACKAGING)) можно включить фоновую проактивную актуализацию (refresh‑ahead) перед истечением TTL, чтобы избежать «штормов» промахов

Техническая схема:
- MES API (C#) -> Redis как кеш первого уровня для ключей:
  - mes:orders:list:{status}:{page}:{filter_hash}
  - mes:orders:count:{status}
  - mes:orders:recent:{page}
- TTL базовый: 30–60 с для списков и 15–30 с для счётчиков (тонкая настройка по нагрузке)

Ключевые моменты на диаграммах:
- Cache‑Aside чтение: проверка Redis → промах → SQL (read‑replica при наличии) → запись в Redis → ответ
- Инвалидация: по событиям изменения статуса/создания нового заказа из RabbitMQ - targeted delete/изменение счётчиков

Диаграммы последовательностей
- [Диаграмма чтения списка заказов](./read_orders.puml)
- [Диаграмма инвалидации кеша при смене статуса заказа](./change_order_status.puml)


## 4 Стратегия инвалидации кеша
Используем комбинированную стратегию:
- Временная (TTL): базовая свежесть данных без сложной логики инвалидации
- По ключу (event‑driven): программная инвалидация при событиях изменения статуса и создании заказов

Детали:
- При получении события о смене статуса order_id из RabbitMQ:
  - удалить/обновить ключи сегментов, на которые влияет заказ: mes:orders:list:{old_status}:* и mes:orders:list:{new_status}:page=1;
  - обновить mes:orders:count:{old_status}–1 и mes:orders:count:{new_status}+1 (или удалить, чтобы пересчиталось);
  - инвалидация ленты новых заказов: mes:orders:recent:page=1

Сравнение стратегий:
- Только TTL
  - + просто, минимум кода
  - − устаревшие данные до 60 с; не решает потребности «видеть новые заказы мгновенно»
- Только по ключу (event‑driven)
  - + актуальность почти в реальном времени
  - − сложнее реализация; нужно аккуратно определить затрагиваемые сегменты и страницы
- Комбинация TTL + по ключу (выбор)
  - + баланс простоты и свежести; TTL защищает от пропущенных событий, key‑invalidation ускоряет критичные сегменты
  - − требуется поддержка подписки на события (RabbitMQ consumer) в MES API


## 5 Альтернативы
Вариант A (выбран): Redis Cache‑Aside + TTL + event‑invalidate + точечный Refresh‑Ahead
- Плюсы: контроль приложения, высокая предсказуемость, простая поэтапная раскатка, хорош под списки
- Минусы: требуется поддерживать инвалидацию и ключи

Вариант B: HTTP Edge‑кеширование (CDN/Reverse Proxy) для API дашборда
- Плюсы: разгрузка бэкенда без кода на приложении, простая интеграция
- Минусы: сложнее тонко инвалидировать по событиям; персональные фильтры/авторизация мешают эффективному шерингу; риск устаревших данных

Итог: серверный Redis Cache‑Aside с событийной инвалидацией - оптимальный баланс для MES дашборда
