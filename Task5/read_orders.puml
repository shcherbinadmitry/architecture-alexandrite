@startuml
title MES — Чтение списка заказов: Cache-Aside с Redis

actor Operator as Op
participant "MES Web UI\n(Браузер)" as Web
participant "MES API\n(OrdersController)" as Api
participant "CacheService\n(Cache-Aside)" as Cache
database "Redis" as Redis
database "SQL (Read Replica)" as DB

note over Api,Cache
TTL: списки 30–60 c (тонкая настройка по нагрузке)
Кешируются первые N страниц и типовые фильтры
end note

Op -> Web: Открыть дашборд / список заказов
Web -> Api: GET /orders?status=...&page=...&filters...

Api -> Cache: BuildKey(status, page, filter_hash, status)
Cache -> Redis: GET mes:orders:list:{status}:{page}:{filter_hash}

alt Cache HIT
  Redis --> Cache: cached orders[]
  Cache --> Api: orders[]
  Api --> Web: 200 OK (orders[])

else Cache MISS
  alt Первый запрос
    Cache -> DB: SELECT ... FROM orders WHERE ...\nLIMIT ... OFFSET ...
    DB --> Cache: orders[]
    Cache -> Redis: SETEX mes:orders:list:{...} value TTL=30..60s
    Cache --> Api: orders[]
    Api --> Web: 200 OK (orders[])
  else Дублирующий запрос (ожидание)
    Cache -> Redis: GET mes:orders:list:{...}
    Redis --> Cache: cached orders[]
    Cache --> Api: orders[]
    Api --> Web: 200 OK (orders[])
  end
end

legend right
Участники кеширования:
- CacheService (формирование ключей, TTL)
- Redis (in-memory хранилище)
- SQL Read Replica (источник истины при промахе)
- HTTP-кеш заголовки (браузер)
end legend

@enduml
