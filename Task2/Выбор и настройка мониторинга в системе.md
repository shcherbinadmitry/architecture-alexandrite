# Выбор и настройка мониторинга в системе

## Мотивация
Мониторинг нужен, чтобы прекратить работу «по жалобам» и перейти к управлению по данным

Без технического мониторинга команда не видит:
- где теряются заказы (интеграции, очереди),
- когда и почему тормозит MES (длинные очереди расчётов, CPU/GPU/IO),
- узкие места дашборда операторов (медленные запросы/индексы),
- сбои инфраструктуры

Ожидаемый эффект для бизнеса:
- снижение потерь выручки за счёт раннего обнаружения проблем с доставкой заказов и статусов;
- сокращение времени реагирования за счёт алертов и видимости причин;
- прогнозируемый SLA по ключевым потокам (создание заказа, расчёт, смена статусов, отгрузка);
- данные для планирования ёмкости и масштабирования под линейный рост

## Выбор подхода к мониторингу
Используем комбинированный подход:
- Для внешних API и пользовательских сценариев - RED (Rate, Errors, Duration)
- Для инфраструктуры - USE (Utilization, Saturation, Errors)
- Для сетевых и общесистемных аспектов - «Четыре золотых сигнала» (latency, traffic, errors, saturation)
Это позволяет одновременно контролировать бизнес‑критичные запросы и технические ресурсы

### Глобальные принципы по настройкам уведомления насыщенности
- Желаемый запас: 20–30% по ресурсам, фильтруем всплески.
- Сочетатать мгновенные (instant) и скользящие окна (rate_over_sum/irate/avg_over_time) для отличия пиков от устойчивых перегрузок.
- План действий:
  - P1: авто-скейл, эскалация в звонилку, тикет на инцидент, аннотация в Grafana
  - P2: создание тикета, уведомление в чат, перезапуск подов консьюмера

## Метрики и ярлыки (labels)
Соответствие предоставленному списку метрик: выбор, назначение и ярлыки

1) Number of `dead-letter-exchange` letters in RabbitMQ - отслеживаем
- зачем: инциденты доставки/обработки, потери заказов и статусов
- labels: vhost, queue, dlq, reason, service, environment

2) Number of message `in flight` in RabbitMQ - отслеживаем
- зачем: загрузка консьюмеров и риск простоя очереди
- labels: vhost, queue, consumer_group, service, environment

3) Number of requests (RPS) for internet shop API - отслеживаем
- зачем: объём трафика, расчет пропускной способности
- labels: service=shop, endpoint, method, http_status, channel (site|api_b2b), partner_id, environment

4) Number of requests (RPS) for CRM API - отслеживаем
- labels: service=crm, endpoint, method, http_status, environment

5) Number of requests (RPS) for MES API - отслеживаем
- labels: service=mes, endpoint, method, http_status, client_type (operator|system), environment

6) Number of requests (RPS) per user for internet shop API - частично
- зачем: выявление аномалий/перегрузок
- как: группируем по user_segment, channel, partner_id

7) Number of requests (RPS) per user for CRM API - частично
- labels: role=sales|admin, team_id per‑user - через отчёты/логи

8) Number of requests (RPS) per user for MES API - частично
- labels: operator_role, shift_id per-operator - через отчёты/логи

9) CPU % for shop API - отслеживаем
- labels: service=shop, node, instance_type, environment

10) CPU % for CRM API - отслеживаем
- labels: service=crm, node, instance_type, environment

11) CPU % for MES API - отслеживаем
- labels: service=mes, node, instance_type, environment

12) Memory Utilisation for shop API - отслеживаем
- labels: service=shop, node, environment

13) Memory Utilisation for CRM API - отслеживаем
- labels: service=crm, node, environment

14) Memory Utilisation for MES API - отслеживаем
- labels: service=mes, node, environment

15) Memory Utilisation for shop db instance - отслеживаем
- labels: db=shop, role=primary|replica, node/instance, 

16) Memory Utilisation for MES db instance - отслеживаем
- labels: db=mes, role=primary|replica, node/instance, 

17) Number of connections for shop db instance - отслеживаем
- labels: db=shop, role, service=shop|crm, node/instance

18) Number of connections for MES db instance - отслеживаем
- labels: db=mes, role, service=mes, node/instance

19) Response time (latency) for shop API - отслеживаем
- зачем: RED Duration
- labels: service=shop, endpoint, method, channel, partner_id

20) Response time (latency) for CRM API - отслеживаем
- labels: service=crm, endpoint, method

21) Response time (latency) for MES API - отслеживаем
- labels: service=mes, endpoint, method, client_type

22) Size of S3 storage - отслеживаем
- зачем: ёмкость/затраты, риск переполнения
- labels: bucket, storage_class, environment

23) Size of shop db instance - отслеживаем
- labels: db=shop, instance; дополнительно: table

24) Size of MES db instance - отслеживаем
- labels: db=mes, instance

25) Number of `HTTP 200` for shop API - не отдельной метрикой
- как: агрегируем из http_requests_total по status=200

26) Number of `HTTP 200` for CRM API - не отдельной метрикой
- как: агрегируем из http_requests_total по status=200

27) Number of `HTTP 200` for MES API - не отдельной метрикой
- как: агрегируем из http_requests_total по status=200

28) Number of `HTTP 500` for shop API - не отдельной метрикой
- как: агрегируем из http_requests_total по status=5xx; также ведём http_request_errors_total с error_class

29) Number of `HTTP 500` for CRM API - не отдельной метрикой
- как: как выше

30) Number of `HTTP 500` for MES API - не отдельной метрикой
- как: как выше

31) Number of simultanious sessions for shop API - опционально
- labels (если используется): service=shop, auth

32) Number of simultanious sessions for CRM API - опционально
- labels (если используется): service=crm, role 

33) Number of simultanious sessions for MES API - опционально
- labels (если используется): service=mes, operator_role

34) Kb tranferred (received) for shop API - отслеживаем агрегировано
- зачем: ёмкость сети, расходы, аномалии
- labels: service=shop, node; endpoint опционально

35) Kb tranferred (received) for CRM API - отслеживаем агрегировано
- labels: service=crm, node

36) Kb tranferred (received) for MES API - отслеживаем агрегировано
- labels: service=mes, node

37) Kb provided (sent) for shop API - отслеживаем агрегировано
- labels: service=shop, node

38) Kb provided (sent) for CRM API - отслеживаем агрегировано
- labels: service=crm, node

39) Kb provided (sent) for MES API - отслеживаем агрегировано
- labels: service=mes, node

Дополнительные метрики, которые добавляем сверх списка:
- DLQ rate и доля DLQ/total сообщений по очередям - для приоритизации инцидентов
- mes_calc_jobs_* (поток/длительность/ошибки/в работе) - SLA расчётов MES
- db_replica_lag_seconds, db_deadlocks_total - целостность и производительность чтения/записи
- dashboard_* (duration, cache_hits/misses, new_orders_lag) - UX операторов и справедливое распределение заказов
- api_partner_error_rate - качество интеграций по каждому партнёру

## План внедрения
### Этап 1 - базовая Observability‑платформа
- Подключить OpenTelemetry SDK/экспортеры; Prometheus, Grafana, лог‑хранилище (ELK/Yandex Managed Service)
- Стартовые RED‑дашборды по API, USE по инфраструктуре; алерты по 5xx ошибкам, длине очередей

### Этап 2 - очереди, воркеры и дашборд MES
- Метрики по RabbitMQ (длина, DLQ, консьюмеры), worker‑pool (in‑progress, duration, failures), кэш‑метрики
- Дашборд операторов: duration запросов, cache hits/misses, lag новых заказов

### Этап 3 - БД и бизнес‑SLI
- Экспорт метрик БД: query duration, replica lag, deadlocks;
- Бизнес‑метрики в отдельный namespace

### Этап 4 - Постоянно: отладка алертов и оптимизация
- Регулярные пост‑мортемы; корректировка порогов, доработка ярлыков, улучшения запросов и индексов




